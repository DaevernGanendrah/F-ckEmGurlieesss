<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- ✅ Correct mobile viewport + safe areas -->
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>LEAVE em GURLIEESS — 8-BIT BOSS RUSH</title>
  <style>
    :root{
      --bg:#05040a;
      --border:rgba(255,255,255,.14);

      /* ✅ Goth-cat palette for title screen */
      --night1:#05040a;
      --night2:#0b0620;
      --night3:#14083a;
      --purple:#7a2cff;
      --purple2:#b06bff;
      --pink:#ff6bd6;
      --blue:#7aa7ff;
      --gold:#ffd66b;
      --white:#e8f2ff;
      --ink:#02020a;

      --scale: 5; /* desktop integer scale */
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--white);}
    body{
      display:flex;align-items:center;justify-content:center;overflow:hidden;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      touch-action: manipulation;
    }
    .crt::before{
      content:""; position:fixed; inset:-2px;
      background:
        radial-gradient(1200px 800px at 50% 60%, rgba(122,44,255,.10), transparent 60%),
        radial-gradient(900px 600px at 55% 45%, rgba(255,107,214,.08), transparent 55%);
      pointer-events:none; mix-blend-mode: screen;
    }
    .crt::after{
      content:""; position:fixed; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.045),
        rgba(255,255,255,.045) 1px,
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,0) 4px
      );
      opacity:.18; pointer-events:none;
    }

    #frame{
      position:relative;
      border-radius:18px;
      border:1px solid var(--border);
      box-shadow: 0 25px 70px rgba(0,0,0,.7);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      padding:14px;
    }

    #screen{
      display:block;
      width: calc(320px * var(--scale));
      height: calc(180px * var(--scale));
      background: var(--ink);
      border-radius:12px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      cursor: default;
      touch-action: manipulation;
    }

    /* ✅ This wrapper lets us rotate/scale the canvas on mobile */
    #mobileStage{
      position:relative;
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }
    #mobileRotator{
      transform-origin: center center;
      will-change: transform;
    }

    /* ✅ Mobile “Rotate to Landscape” hint (shown only when portrait on mobile) */
    #rotateHint{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:28px;
      background: rgba(0,0,0,.78);
      z-index: 9999;
      backdrop-filter: blur(3px);
    }
    #rotateHint .box{
      max-width: 520px;
      border:2px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.68);
      border-radius:14px;
      padding:18px 16px;
      box-shadow: 0 18px 50px rgba(0,0,0,.65);
    }
    #rotateHint .ttl{
      font-weight:900;
      letter-spacing:1px;
      margin:0 0 10px;
      color: var(--gold);
      text-transform:uppercase;
      font-size:14px;
    }
    #rotateHint .msg{
      margin:0;
      opacity:.92;
      line-height:1.55;
      font-size:13px;
      color: var(--white);
    }

    #toast{
      position:absolute;
      left:50%;
      bottom:18px;
      transform: translateX(-50%);
      padding:10px 12px;
      background: rgba(0,0,0,.75);
      border:2px solid rgba(255,255,255,.14);
      border-radius:10px;
      font-size:12px;
      letter-spacing:.3px;
      display:none;
      max-width: 86%;
      text-align:center;
      -webkit-tap-highlight-color: transparent;
      z-index: 30;
    }

    /* ✅ FULLSCREEN MOBILE (iPhone 12+) */
    @media (max-width: 900px), (pointer: coarse) {
      body{align-items:stretch;justify-content:stretch;}

      #frame{
        position:fixed;
        inset:0;
        padding:0;
        border:none;
        border-radius:0;
        box-shadow:none;
        background:#000;

        /* safe-area padding */
        padding-top: env(safe-area-inset-top);
        padding-right: env(safe-area-inset-right);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);

        display:flex;
        align-items:stretch;
        justify-content:stretch;
      }

      #mobileStage{ width:100%; height:100%; }

      /* canvas itself will be sized by JS */
      #screen{
        width: 320px;
        height: 180px;
        border-radius:0;
      }
    }
  </style>
</head>
<body class="crt">
  <div id="frame">
    <div id="mobileStage">
      <div id="mobileRotator">
        <canvas id="screen" width="320" height="180"></canvas>
      </div>
    </div>

    <div id="toast"></div>
  </div>

  <!-- ✅ Portrait hint -->
  <div id="rotateHint">
    <div class="box">
      <div class="ttl">Rotate to Landscape</div>
      <p class="msg">
        This game is designed for <b>landscape</b> on mobile so it fills the whole screen.
        Rotate your phone sideways.
      </p>
    </div>
  </div>

<script>
(() => {
  /* =========================
     CONFIG
     ========================= */
  const CONFIG = {
    playerSpeed: 2.8,
    bulletSpeed: 4.9,

    // ✅ slows ALL cutscene pacing (text + phase timing)
    cutsceneSlow: 2.2,

    // ✅ slows heart crack
    heartCrackDuration: 170,

    tiers: {
      easy: { hp: 6,  speed: 0.85, dodge: 0.20, jitter: 0.08 },
      hard: { hp: 10, speed: 1.15, dodge: 0.45, jitter: 0.11 },
      nat:  { hp: 18, speed: 1.35, dodge: 0.70, jitter: 0.14 }
    },
    heartTitle: "DATE NIGHT UNLOCKED"
  };

  const canvas = document.getElementById("screen");
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = false;

  const toast = document.getElementById("toast");
  const mobileRotator = document.getElementById("mobileRotator");
  const rotateHint = document.getElementById("rotateHint");

  let keys = {};
  let game = null;

  // ✅ Heart clickable area (computed each frame)
  let heartHitRect = null;

  const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
  function rectHit(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  function showToast(msg){
    toast.textContent = msg;
    toast.style.display = "block";
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.style.display = "none", 1400);
  }

  function isMobileLike(){
    return matchMedia("(pointer: coarse)").matches || window.innerWidth < 900;
  }

  /* =========================
     ✅ LANDSCAPE-FIRST MOBILE FIT
     ========================= */
  function fitCanvasLandscapeMobile(){
    const vw = window.visualViewport ? window.visualViewport.width : window.innerWidth;
    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;

    const mobile = isMobileLike();

    if (!mobile){
      mobileRotator.style.transform = "none";
      rotateHint.style.display = "none";

      const s = Math.min(vw / canvas.width, vh / canvas.height);
      canvas.style.width  = Math.floor(canvas.width  * s) + "px";
      canvas.style.height = Math.floor(canvas.height * s) + "px";
      return;
    }

    const portrait = vh > vw;

    if (portrait){
      rotateHint.style.display = "flex";

      const scale = Math.min(vw / canvas.height, vh / canvas.width);
      const targetW = Math.floor(canvas.width * scale);
      const targetH = Math.floor(canvas.height * scale);

      canvas.style.width  = targetW + "px";
      canvas.style.height = targetH + "px";

      mobileRotator.style.transform = `rotate(90deg)`;
    } else {
      rotateHint.style.display = "none";

      const scale = Math.min(vw / canvas.width, vh / canvas.height);
      const targetW = Math.floor(canvas.width * scale);
      const targetH = Math.floor(canvas.height * scale);

      canvas.style.width  = targetW + "px";
      canvas.style.height = targetH + "px";

      mobileRotator.style.transform = "none";
    }
  }

  window.addEventListener("resize", fitCanvasLandscapeMobile, { passive:true });
  window.addEventListener("orientationchange", () => setTimeout(fitCanvasLandscapeMobile, 80), { passive:true });
  if (window.visualViewport){
    window.visualViewport.addEventListener("resize", fitCanvasLandscapeMobile, { passive:true });
  }

  /* =========================
     ✅ MOBILE INPUT: TILT to move, TAP to shoot / start
     ========================= */
  let tilt = {
    enabled: false,
    x: 0,
    dead: 0.06,
    max: 0.45,
    smooth: 0.18
  };

  function requestMotionPermissionIfNeeded(){
    try{
      if (typeof DeviceMotionEvent !== "undefined" &&
          typeof DeviceMotionEvent.requestPermission === "function"){
        return DeviceMotionEvent.requestPermission().then(state => state === "granted");
      }
    } catch(e){}
    return Promise.resolve(true);
  }

  function setupTilt(){
    if (!isMobileLike()) return;

    requestMotionPermissionIfNeeded().then(granted => {
      if (!granted){
        showToast("MOTION BLOCKED — USE KEYS");
        return;
      }
      tilt.enabled = true;

      window.addEventListener("deviceorientation", (e) => {
        const g = (typeof e.gamma === "number") ? e.gamma : 0;
        let nx = g / 45;
        nx = clamp(nx, -tilt.max, tilt.max);
        tilt.x = tilt.x + (nx - tilt.x) * tilt.smooth;
      }, { passive:true });

      showToast("TILT TO MOVE • TAP TO SHOOT");
    }).catch(()=>{});
  }

  function startGameFromTitle(){
    if (!game) return;
    game.state = "play";
    setupTilt();
    showToast("GO GO GO!");
  }

  // Tap anywhere: start on title, shoot on play, crack heart on heart screen.
  function onTap(clientX, clientY){
    if (!game) return;

    const rect = canvas.getBoundingClientRect();
    const mx = ((clientX - rect.left) * (canvas.width / rect.width))|0;
    const my = ((clientY - rect.top) * (canvas.height / rect.height))|0;

    if (game.state === "title"){
      startGameFromTitle();
      return;
    }

    if (game.state === "heart" && heartHitRect){
      const b = heartHitRect;
      const inside = (mx>=b.x && mx<=b.x+b.w && my>=b.y && my<=b.y+b.h);
      if (inside){ startHeartCrack(); return; }
    }

    if (game.state === "play") shoot();
  }

  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    onTap(e.clientX, e.clientY);
  }, { passive:false });

  /* =========================
     8-bit bitmap font (crisp)
     ========================= */
  const FONT5x7 = {
    "A":["01110","10001","10001","11111","10001","10001","10001"],
    "B":["11110","10001","10001","11110","10001","10001","11110"],
    "C":["01110","10001","10000","10000","10000","10001","01110"],
    "D":["11110","10001","10001","10001","10001","10001","11110"],
    "E":["11111","10000","10000","11110","10000","10000","11111"],
    "F":["11111","10000","10000","11110","10000","10000","10000"],
    "G":["01110","10001","10000","10111","10001","10001","01110"],
    "H":["10001","10001","10001","11111","10001","10001","10001"],
    "I":["11111","00100","00100","00100","00100","00100","11111"],
    "J":["11111","00010","00010","00010","10010","10010","01100"],
    "K":["10001","10010","10100","11000","10100","10010","10001"],
    "L":["10000","10000","10000","10000","10000","10000","11111"],
    "M":["10001","11011","10101","10101","10001","10001","10001"],
    "N":["10001","11001","10101","10011","10001","10001","10001"],
    "O":["01110","10001","10001","10001","10001","10001","01110"],
    "P":["11110","10001","10001","11110","10000","10000","10000"],
    "Q":["01110","10001","10001","10001","10101","10010","01101"],
    "R":["11110","10001","10001","11110","10100","10010","10001"],
    "S":["01111","10000","10000","01110","00001","00001","11110"],
    "T":["11111","00100","00100","00100","00100","00100","00100"],
    "U":["10001","10001","10001","10001","10001","10001","01110"],
    "V":["10001","10001","10001","10001","10001","01010","00100"],
    "W":["10001","10001","10001","10101","10101","11011","10001"],
    "X":["10001","10001","01010","00100","01010","10001","10001"],
    "Y":["10001","10001","01010","00100","00100","00100","00100"],
    "Z":["11111","00001","00010","00100","01000","10000","11111"],
    "0":["01110","10001","10011","10101","11001","10001","01110"],
    "1":["00100","01100","00100","00100","00100","00100","01110"],
    "2":["01110","10001","00001","00010","00100","01000","11111"],
    "3":["11110","00001","00001","01110","00001","00001","11110"],
    "4":["00010","00110","01010","10010","11111","00010","00010"],
    "5":["11111","10000","10000","11110","00001","00001","11110"],
    "6":["01110","10000","10000","11110","10001","10001","01110"],
    "7":["11111","00001","00010","00100","01000","01000","01000"],
    "8":["01110","10001","10001","01110","10001","10001","01110"],
    "9":["01110","10001","10001","01111","00001","00001","01110"],
    ":":["00000","00100","00100","00000","00100","00100","00000"],
    "-":["00000","00000","00000","11111","00000","00000","00000"],
    ".":["00000","00000","00000","00000","00000","00100","00100"],
    "!":["00100","00100","00100","00100","00100","00000","00100"],
    "'":["00100","00100","00000","00000","00000","00000","00000"],
    "/":["00001","00010","00100","01000","10000","00000","00000"],
    "<":["00010","00100","01000","10000","01000","00100","00010"],
    ">":["01000","00100","00010","00001","00010","00100","01000"],
    "+" :["00000","00100","00100","11111","00100","00100","00000"],
    " ":[ "00000","00000","00000","00000","00000","00000","00000" ]
  };

  function drawPixelText(text, x, y, color="#e8f2ff", scale=1, spacing=1){
    text = String(text).toUpperCase();
    ctx.fillStyle = color;
    let cx = x|0, cy = y|0;
    for (const ch of text){
      const glyph = FONT5x7[ch] || FONT5x7[" "];
      for (let row=0; row<7; row++){
        const line = glyph[row];
        for (let col=0; col<5; col++){
          if (line[col]==="1"){
            ctx.fillRect((cx + col*scale)|0, (cy + row*scale)|0, scale, scale);
          }
        }
      }
      cx += (5*scale + spacing);
    }
  }

  function textWidthPx(text, scale=1, spacing=1){
    return String(text).length * (5*scale + spacing) - spacing;
  }

  function drawDialogue(lines, color1="#e8f2ff", color2="#ffd66b"){
    const boxX=6, boxY=142, boxW=308, boxH=32;
    ctx.fillStyle="rgba(0,0,0,.72)";
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle="rgba(255,255,255,.16)";
    ctx.strokeRect(boxX+0.5, boxY+0.5, boxW-1, boxH-1);

    ctx.fillStyle="rgba(255,107,214,.18)";
    ctx.fillRect(boxX+6, boxY+6, 12, 12);
    ctx.fillStyle="rgba(255,107,214,.55)";
    ctx.fillRect(boxX+8, boxY+10, 8, 4);

    const l1 = (lines && lines[0]) ? lines[0] : "";
    const l2 = (lines && lines[1]) ? lines[1] : "";
    drawPixelText(l1, boxX+24, boxY+7,  color1, 1, 1);
    if (l2) drawPixelText(l2, boxX+24, boxY+19, color2, 1, 1);
  }

  function px(x,y){ ctx.fillRect(x|0,y|0,1,1); }
  function psc(x,y,sc){ ctx.fillRect(x|0,y|0,sc,sc); }

  /* =========================
     ✅ TITLE SCREEN (NEW)
     ========================= */
  function drawNightGradient(){
    const g = ctx.createLinearGradient(0,0,0,180);
    g.addColorStop(0, "#05040a");
    g.addColorStop(0.55, "#0b0620");
    g.addColorStop(1, "#14083a");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,320,180);
  }

  function drawStars(t){
    for(let i=0;i<70;i++){
      const x = (i*47 + t*1) % 320;
      const y = (i*73 + t*2) % 120;
      ctx.fillStyle = (i%9===0) ? "rgba(255,214,107,.9)" : "rgba(232,242,255,.65)";
      ctx.fillRect(x|0, y|0, 1, 1);
    }
  }

  function drawNeonCloud(x,y){
    ctx.fillStyle="rgba(232,242,255,.14)";
    ctx.fillRect(x+2,y+2, 18,6);
    ctx.fillRect(x,y+4, 22,8);
    ctx.fillRect(x+5,y, 12,6);
    ctx.fillStyle="rgba(122,44,255,.25)";
    ctx.fillRect(x+1,y+12, 20,1);
  }

  function drawBat(x,y,flap){
    ctx.fillStyle="rgba(0,0,0,.72)";
    ctx.fillRect(x, y+2, 12, 2);
    ctx.fillRect(x+2, y+1, 8, 1);
    ctx.fillRect(x+2, y+4, 8, 1);
    ctx.fillRect(x+5, y+2, 2, 4);
    ctx.fillRect(x+4, y+1, 1, 1);
    ctx.fillRect(x+7, y+1, 1, 1);
    if (flap){ ctx.fillRect(x+1, y+0, 10, 1); }
    ctx.fillStyle="rgba(255,107,214,.75)";
    ctx.fillRect(x+5, y+3, 1, 1);
    ctx.fillRect(x+6, y+3, 1, 1);
  }

  function drawGothCitySilhouette(){
    ctx.fillStyle="rgba(0,0,0,.85)";
    ctx.fillRect(0,124,320,56);

    for(let x=0;x<320;x+=26){
      const h = 18 + ((x*31)%26);
      ctx.fillStyle="rgba(0,0,0,.92)";
      ctx.fillRect(x, 124-h, 18, h);

      ctx.fillStyle = "rgba(122,44,255,.22)";
      for(let wy=124-h+4; wy<124-4; wy+=6){
        ctx.fillRect(x+4, wy, 2, 2);
        if ((x/26)%2===0) ctx.fillRect(x+10, wy+2, 2, 2);
      }
    }

    ctx.fillStyle="rgba(255,107,214,.10)";
    ctx.fillRect(0,124,320,2);
  }

  function drawCatHeadIcon(cx,cy,scale=2, glow=true){
    const s=scale;
    const x=cx|0, y=cy|0;

    if (glow){
      ctx.fillStyle="rgba(122,44,255,.22)";
      ctx.fillRect(x-10*s, y-10*s, 20*s, 20*s);
    }

    const p=(xx,yy,c)=>{ ctx.fillStyle=c; ctx.fillRect(x+xx*s, y+yy*s, s, s); };
    const DARK="#0b0b14", PINK="#ff6bd6", PURP="#7a2cff", W="#e8f2ff";

    p(-4,-6,DARK); p(-3,-7,DARK); p(-2,-8,DARK);
    p( 4,-6,DARK); p( 3,-7,DARK); p( 2,-8,DARK);

    for(let xx=-6;xx<=6;xx++) p(xx,-4,DARK);
    p(-7,-3,DARK); p(7,-3,DARK);
    p(-8,-2,DARK); p(8,-2,DARK);
    p(-8,-1,DARK); p(8,-1,DARK);
    p(-7,0,DARK);  p(7,0,DARK);
    for(let xx=-6;xx<=6;xx++) p(xx,1,DARK);
    for(let xx=-5;xx<=5;xx++) p(xx,2,DARK);

    for(let yy=-3;yy<=0;yy++) for(let xx=-6;xx<=6;xx++) p(xx,yy,PINK);

    p(-2,-3,PURP); p(-1,-3,PURP); p(0,-3,PURP); p(1,-3,PURP);
    p(-1,-2,PURP); p(0,-2,PURP);

    p(-3,-1,"#7aa7ff"); p(2,-1,"#7aa7ff");
    p(-2,-1,W); p(3,-1,W);

    p(0,0,"#ffd66b");
  }

  function drawOutlinedBig(text, cx, y, fill, scale=3){
    const outline = "#000";
    const w = textWidthPx(text, scale, 1);
    const x = (cx - w/2)|0;

    const off = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,-1],[-1,1],[1,1]];
    for(const [ox,oy] of off){
      drawPixelText(text, x+ox, y+oy, outline, scale, 1);
    }
    drawPixelText(text, x, y, fill, scale, 1);
    drawPixelText(text, x, y-1, "rgba(255,255,255,.18)", scale, 1);
  }

  function drawPressStart(){
    const blink = ((game.t/22)|0) % 2 === 0;
    const msg = blink ? "TAP TO START" : "            ";
    const w = textWidthPx(msg, 2, 1);
    drawPixelText(msg, (160 - w/2)|0, 110, "#e8f2ff", 2, 1);

    drawPixelText("MOVE: TILT / KEYS   SHOOT: TAP / SPACE", 34, 152, "rgba(232,242,255,.80)", 1, 1);
    drawPixelText("P: PAUSE   R: RESET", 104, 164, "rgba(255,107,214,.78)", 1, 1);
  }

  function drawTitleScreen(){
    drawNightGradient();
    drawStars(game.t);

    ctx.fillStyle="rgba(122,44,255,.10)";
    ctx.fillRect(0,42,320,54);
    ctx.fillStyle="rgba(255,107,214,.06)";
    ctx.fillRect(0,58,320,30);

    drawNeonCloud(24,26);
    drawNeonCloud(210,18);
    drawNeonCloud(146,34);

    const flap = ((game.t/10)|0) % 2 === 0;
    drawBat(54,20,flap);
    drawBat(260,34,!flap);

    drawGothCitySilhouette();

    drawOutlinedBig("FUCK EM", 160, 34, "#ff6bd6", 3);
    drawOutlinedBig("GURLIEESS", 160, 60, "#7a2cff", 3);

    const sub = "Daev misses Yuzu";
    const sw = textWidthPx(sub, 2, 1);
    const boxW = sw + 18;
    const boxX = (160 - boxW/2)|0;
    const boxY = 86;

    ctx.fillStyle="rgba(0,0,0,.50)";
    ctx.fillRect(boxX, boxY, boxW, 18);
    ctx.strokeStyle="rgba(255,255,255,.16)";
    ctx.strokeRect(boxX+0.5, boxY+0.5, boxW-1, 17);
    drawPixelText(sub, boxX+9, boxY+5, "#ffd66b", 2, 1);

    drawCatHeadIcon(64, 80, 2, true);
    drawCatHeadIcon(256, 80, 2, true);

    drawPressStart();
  }

  /* =========================
     PLAYER + MALE CAT
     ========================= */
  function drawPlayerVampireCat(x, y, sc, form){
    const PINK = "#ff6bd6";
    const HOT  = "#ff9be7";
    const DARK = "#0b0b14";
    const PURP = "#7a2cff";
    const EYE  = "#7aa7ff";
    const WHITE= "#e8f2ff";
    const GOLD = "#ffd66b";
    const RED  = "#ff3b7a";
    const p = (xx,yy,color)=>{ ctx.fillStyle = color; psc(x + xx*sc, y + yy*sc, sc); };

    p(2,0,DARK); p(3,0,DARK);
    p(8,0,DARK); p(9,0,DARK);
    p(3,1,DARK); p(8,1,DARK);
    for(let xx=2; xx<=9; xx++) p(xx,2,DARK);
    p(1,3,DARK); p(10,3,DARK);
    p(1,4,DARK); p(10,4,DARK);
    p(1,5,DARK); p(10,5,DARK);
    p(2,6,DARK); p(9,6,DARK);
    for(let xx=3; xx<=8; xx++) p(xx,7,DARK);

    for(let yy=3; yy<=6; yy++){
      for(let xx=2; xx<=9; xx++){
        if ((xx===2||xx===9) && yy===6) continue;
        if ((xx===2||xx===9) && yy===3) continue;
        p(xx,yy,PINK);
      }
    }
    p(3,3,HOT); p(4,3,HOT); p(7,3,HOT); p(8,3,HOT);

    p(4,4,EYE); p(7,4,EYE);
    p(5,4,WHITE); p(8,4,WHITE);
    p(4,5,DARK); p(7,5,DARK);

    p(6,5,HOT);
    p(5,6,WHITE); p(6,6,WHITE); p(7,6,WHITE);

    p(11,6,DARK); p(11,7,DARK); p(10,8,DARK);
    p(5,8,DARK); p(6,8,DARK);
    p(4,9,DARK); p(7,9,DARK);
    p(5,9,PURP); p(6,9,PURP);

    if (form >= 1){ p(5,7,WHITE); p(7,7,WHITE); p(6,8,RED); }
    if (form >= 2){
      p(0,7,DARK); p(1,8,DARK); p(10,8,DARK); p(11,7,DARK);
      p(0,8,DARK); p(0,9,DARK); p(11,8,DARK); p(11,9,DARK);
      p(1,9,PURP); p(10,9,PURP);
    }
    if (form >= 3){
      p(0,5,DARK); p(0,6,DARK); p(1,5,DARK); p(1,6,DARK);
      p(0,4,PURP);
      p(11,5,DARK); p(11,6,DARK); p(10,5,DARK); p(10,6,DARK);
      p(11,4,PURP);
      p(2,6,PURP); p(9,6,PURP);
    }
    if (form >= 4){
      p(5,0,GOLD); p(6,0,GOLD);
      p(4,1,GOLD); p(7,1,GOLD);
      p(6,1,WHITE);
    }
  }

  function drawMaleCat(x, y, sc, phase){
    const DARK="#0b0b14", WHITE="#e8f2ff", BLUE="#7aa7ff", GOLD="#ffd66b";
    const p=(xx,yy,c)=>{ ctx.fillStyle=c; psc(x+xx*sc,y+yy*sc,sc); };

    p(2,0,DARK); p(3,0,DARK);
    p(8,0,DARK); p(9,0,DARK);
    p(3,1,DARK); p(8,1,DARK);
    for(let xx=2; xx<=9; xx++) p(xx,2,DARK);
    p(1,3,DARK); p(10,3,DARK);
    p(1,4,DARK); p(10,4,DARK);
    p(1,5,DARK); p(10,5,DARK);
    p(2,6,DARK); p(9,6,DARK);
    for(let xx=3; xx<=8; xx++) p(xx,7,DARK);

    for(let yy=3; yy<=6; yy++){
      for(let xx=2; xx<=9; xx++){
        if ((xx===2||xx===9) && yy===6) continue;
        if ((xx===2||xx===9) && yy===3) continue;
        p(xx,yy,WHITE);
      }
    }

    p(4,4,BLUE); p(7,4,BLUE);
    p(5,4,WHITE); p(8,4,WHITE);
    p(4,5,DARK); p(7,5,DARK);

    p(6,5,GOLD);
    p(5,8,DARK); p(6,8,DARK);
    p(4,9,DARK); p(7,9,DARK);
    p(5,9,GOLD); p(6,9,GOLD);

    if (phase % 20 < 10){ p(3,10,DARK); p(8,10,DARK); }
    else { p(4,10,DARK); p(7,10,DARK); }
  }

  function getPlayerBaseSize(){ return { w: 12, h: 11 }; }

  /* =========================
     BOSSES (same as before)
     ========================= */
  function drawBossClassic(x,y, name, hp, maxHp, blink=false){
    const alpha = blink ? 0.25 : 1;
    ctx.save(); ctx.globalAlpha = alpha;

    ctx.fillStyle = "#ff6bd6";
    px(x+2,y+0); px(x+4,y+0); px(x+6,y+0); px(x+8,y+0); px(x+10,y+0);
    px(x+3,y+1); px(x+5,y+1); px(x+7,y+1); px(x+9,y+1);

    ctx.fillStyle = "#7aa7ff";
    for(let i=2;i<12;i++) px(x+i,y+2);
    for(let i=1;i<13;i++) px(x+i,y+3);
    for(let i=1;i<13;i++) px(x+i,y+4);
    for(let i=2;i<12;i++) px(x+i,y+5);

    ctx.fillStyle = "#02020a";
    px(x+4,y+4); px(x+9,y+4);

    ctx.fillStyle = "#ffd66b";
    for(let i=3;i<11;i++) px(x+i,y+6);
    px(x+4,y+7); px(x+9,y+7);

    ctx.restore();

    ctx.fillStyle = "rgba(255,255,255,.2)";
    ctx.fillRect(x, y+11, 14, 2);
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.fillRect(x, y+11, Math.max(0, (hp/maxHp)*14), 2);

    drawPixelText(name, x-1, y-10, "#e8f2ff", 1, 1);
  }

  function drawGangsterCat(x,y, name, hp, maxHp, blink=false){
    const W=18;
    const alpha = blink ? 0.25 : 1;
    ctx.save(); ctx.globalAlpha = alpha;

    ctx.fillStyle = "#1a1a22";
    for(let yy=3; yy<=9; yy++) for(let xx=3; xx<=14; xx++) px(x+xx, y+yy);
    for(let yy=5; yy<=8; yy++){ px(x+2,y+yy); px(x+15,y+yy); }

    for(let i=0;i<3;i++){ px(x+4+i, y+3-i); }
    for(let i=0;i<3;i++){ px(x+12+i, y+3-i); }

    ctx.fillStyle = "#3a3a48";
    for(let xx=3; xx<=14; xx++) px(x+xx, y+2);
    for(let xx=5; xx<=12; xx++) px(x+xx, y+1);

    ctx.fillStyle = "#2a2a34";
    for(let xx=4; xx<=6; xx++) px(x+xx, y+4);
    for(let xx=11; xx<=13; xx++) px(x+xx, y+4);

    ctx.fillStyle = "#02020a";
    for(let xx=5; xx<=8; xx++) px(x+xx, y+6);
    for(let xx=10; xx<=13; xx++) px(x+xx, y+6);
    ctx.fillStyle = "#7aa7ff";
    px(x+6,y+6); px(x+11,y+6);

    ctx.fillStyle = "#ffd66b";
    px(x+9,y+8);
    ctx.fillStyle = "#e8f2ff";
    px(x+8,y+9); px(x+9,y+9); px(x+10,y+9);

    ctx.fillStyle = "#ffd66b";
    for(let xx=6; xx<=12; xx++) px(x+xx, y+10);
    px(x+7,y+11); px(x+11,y+11);

    ctx.restore();

    ctx.fillStyle = "rgba(255,255,255,.2)";
    ctx.fillRect(x, y+14, W, 2);
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.fillRect(x, y+14, Math.max(0, (hp/maxHp)*W), 2);

    drawPixelText(name, x, y-10, "#ffd66b", 1, 1);
  }

  function drawNatalieGothCat(x,y, hp, maxHp, blink=false){
    const W=20, H=14;
    const alpha = blink ? 0.25 : 1;
    ctx.save(); ctx.globalAlpha = alpha;

    ctx.fillStyle = "#1a1a22";
    for (let i=0;i<4;i++) px(x+3+i, y+1-i);
    for (let i=0;i<4;i++) px(x+13+i, y+1-i);

    for (let yy=2; yy<=10; yy++) for (let xx=2; xx<=17; xx++) px(x+xx, y+yy);
    for (let yy=5; yy<=9; yy++){ px(x+1, y+yy); px(x+18, y+yy); }

    ctx.fillStyle = "#7a2cff";
    px(x+4,y+1); px(x+5,y+2);
    px(x+14,y+1); px(x+15,y+2);

    ctx.fillStyle = "#ff6bd6";
    px(x+6,y+6); px(x+7,y+6);
    px(x+13,y+6); px(x+14,y+6);

    ctx.fillStyle = "#02020a";
    px(x+7,y+6); px(x+14,y+6);

    ctx.fillStyle = "#ffd66b";
    px(x+10,y+8);

    ctx.fillStyle = "#e8f2ff";
    px(x+9,y+9); px(x+10,y+9); px(x+11,y+9);
    px(x+10,y+10);

    ctx.fillStyle = "#7aa7ff";
    for (let xx=6; xx<=13; xx++) px(x+xx, y+11);
    ctx.fillStyle = "#ffd66b";
    px(x+10, y+12);

    ctx.restore();

    ctx.fillStyle = "rgba(255,255,255,.2)";
    ctx.fillRect(x, y+H+1, W, 2);
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.fillRect(x, y+H+1, Math.max(0, (hp/maxHp)*W), 2);

    drawPixelText("NATALIE", x-2, y-10, "#ff6bd6", 1, 1);
  }

  function bossSizeFor(name){
    const n=name.toLowerCase();
    if (n==="natalie") return {w:20,h:14};
    if (n==="vee" || n==="toni") return {w:18,h:12};
    return {w:14,h:10};
  }

  /* =========================
     HEART BITMAP + DRAW
     ========================= */
  const HEART_BITMAP = [
    "0000001111111111000000111111111100000",
    "0000111111111111110001111111111111000",
    "0001111111111111111011111111111111100",
    "0011111111111111111111111111111111110",
    "0111111111111111111111111111111111111",
    "1111111111111111111111111111111111111",
    "1111111111111111111111111111111111111",
    "1111111111111111111111111111111111111",
    "0111111111111111111111111111111111110",
    "0011111111111111111111111111111111100",
    "0001111111111111111111111111111111000",
    "0000111111111111111111111111111110000",
    "0000011111111111111111111111111100000",
    "0000001111111111111111111111111000000",
    "0000000111111111111111111111110000000",
    "0000000011111111111111111111100000000",
    "0000000001111111111111111111000000000",
    "0000000000111111111111111110000000000",
    "0000000000011111111111111100000000000",
    "0000000000001111111111111000000000000",
    "0000000000000111111111110000000000000",
    "0000000000000011111111100000000000000",
    "0000000000000001111111000000000000000",
    "0000000000000000111110000000000000000",
    "0000000000000000011100000000000000000"
  ];

  function drawHeartBitmapAt(x, y, s=2, clipMode=null){
    const W = HEART_BITMAP[0].length * s;
    const H = HEART_BITMAP.length * s;

    if (clipMode){
      ctx.save();
      if (clipMode==="left") ctx.beginPath(), ctx.rect(x, y, W/2, H), ctx.clip();
      else ctx.beginPath(), ctx.rect(x+W/2, y, W/2, H), ctx.clip();
    }

    ctx.fillStyle="#ff6bd6";
    for(let yy=0; yy<HEART_BITMAP.length; yy++){
      const row = HEART_BITMAP[yy];
      for(let xx=0; xx<row.length; xx++){
        if (row[xx]==="1") ctx.fillRect(x + xx*s, y + yy*s, s, s);
      }
    }
    ctx.fillStyle="rgba(255,255,255,.65)";
    ctx.fillRect(x + 9*s,  y + 5*s,  3*s, 3*s);
    ctx.fillRect(x + 14*s, y + 7*s,  2*s, 2*s);

    if (clipMode) ctx.restore();
  }

  function getHeartRectCentered(cx, cy, s=2){
    const W = HEART_BITMAP[0].length * s;
    const H = HEART_BITMAP.length * s;
    return { x: ((cx - W/2)|0), y: ((cy - H/2)|0), w: W|0, h: H|0 };
  }

  /* =========================
     ITINERARY SCREEN
     ========================= */
  function drawItineraryScreen(){
    ctx.fillStyle="#02020a";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    drawStars(game.t);

    ctx.fillStyle="rgba(0,0,0,.65)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const panelX = 10;
    const panelY = 22;
    const panelW = 300;
    const panelH = 148;

    ctx.fillStyle="rgba(0,0,0,.78)";
    ctx.fillRect(panelX, panelY, panelW, panelH);
    ctx.strokeStyle="rgba(255,255,255,.18)";
    ctx.strokeRect(panelX, panelY, panelW, panelH);

    drawPixelText("ITINERARY UNLOCKED", 72, panelY + 8, "#7cff9f", 1, 1);

    drawPixelText("DATE:", 20, panelY + 26, "#7aa7ff", 1, 1);
    drawPixelText("27TH FEBRUARY", 76, panelY + 26, "#e8f2ff", 1, 1);

    drawPixelText("TIME:", 20, panelY + 38, "#7aa7ff", 1, 1);
    drawPixelText("19:00 ONWARDS", 76, panelY + 38, "#e8f2ff", 1, 1);

    drawPixelText("ITINERARY:", 20, panelY + 52, "#7aa7ff", 1, 1);

    const ORANGE = "#ff9f3c";
    const PINK   = "#ff6ec7";
    const WHITE  = "#e8f2ff";

    const col1 = 20;
    const col2 = 120;
    const col3 = 242;

    function row(n, label, place, time, y){
      drawPixelText(`${n}. ${label}`, col1, y, WHITE, 1, 1);
      drawPixelText(`@${place}`,     col2, y, ORANGE, 1, 1);
      drawPixelText(` ${time}`,     col3, y, PINK,   1, 1);
    }

    row(1, "DINNER", "TORITO",    "20:00",  panelY + 66);
    row(2, "DRINKS", "MIZUKAMI",  "22:00", panelY + 78);
    row(3, "DAZE",   "J.W M KL", "00:00", panelY + 90);
    row(4, "DREAMS", "J.W M KL", "02:00",  panelY + 102);

    //drawPixelText("TAP TO SHOOT • TILT TO MOVE", 42, panelY + 124, "rgba(232,242,255,.85)", 1, 1);
  }

  /* =========================
     HEART SCREEN
     ========================= */
  function drawHeartScreen(){
    ctx.fillStyle="#02020a";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    drawStars(game.t);

    ctx.fillStyle="rgba(0,0,0,.65)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const hcX = (canvas.width/2)|0;
    const hcY = (canvas.height/2 - 6)|0;

    const rect = getHeartRectCentered(hcX, hcY, 2);
    drawHeartBitmapAt(rect.x, rect.y, 2);
    heartHitRect = rect;

    const title = CONFIG.heartTitle;
    const titleWidth = title.length * (5*2 + 1);
    drawPixelText(title, ((canvas.width - titleWidth)/2)|0, (canvas.height/2 + 56)|0, "#7cff9f", 2, 1);

    const sub = "TAP THE HEART";
    const subW = sub.length*(5*1+1)-1;
    drawPixelText(sub, ((canvas.width - subW)/2)|0, (rect.y + rect.h + 10)|0, "#e8f2ff", 1, 1);
  }

  /* =========================
     HEART CRACK REVEAL
     ========================= */
  function startHeartCrack(){
    game.heartCrack = { t:0, duration: CONFIG.heartCrackDuration };
    game.state = "heart_crack";
    showToast("CRACKING...");
  }

  function updateHeartCrack(){
    const hc = game.heartCrack;
    if (!hc) return;
    hc.t++;
    if (hc.t >= hc.duration){
      game.heartCrack = null;
      game.state = "itinerary";
      showToast("ITINERARY REVEALED");
    }
  }

  function drawHeartCrackScreen(){
    drawItineraryScreen();
    const hc = game.heartCrack;
    const p = clamp(hc.t / hc.duration, 0, 1);

    ctx.fillStyle = `rgba(0,0,0,${0.55*(1-p)})`;
    ctx.fillRect(0,0,320,180);

    const hcX = (canvas.width/2)|0;
    const hcY = (canvas.height/2 - 6)|0;
    const rect = getHeartRectCentered(hcX, hcY, 2);

    const ease = 1 - Math.pow(1 - p, 3);
    const split = (ease * 46)|0;
    const drop  = (ease * 10)|0;

    drawHeartBitmapAt(rect.x - split, rect.y + drop, 2, "left");
    drawHeartBitmapAt(rect.x + split, rect.y + drop, 2, "right");

    const crackAlpha = clamp((p*1.8), 0, 1) * (1 - clamp((p-0.82)/0.18,0,1));
    ctx.fillStyle = `rgba(255,214,107,${0.85*crackAlpha})`;
    const midX = rect.x + (rect.w/2)|0;
    const topY = rect.y + 6;
    const botY = rect.y + rect.h - 6;

    let x = midX, y = topY;
    for (let i=0;i<11;i++){
      const nx = x + ((i%2===0)? -3 : 3);
      const ny = y + 10;
      ctx.fillRect(x, y, 2, 2);
      ctx.fillRect(nx, ny, 2, 2);
      ctx.fillRect(((x+nx)/2)|0, ((y+ny)/2)|0, 2, 2);
      x = nx; y = ny;
      if (y > botY) break;
    }

    const msg = "HOLD ON...";
    const mw = msg.length*(5*1+1)-1;
    drawPixelText(msg, ((canvas.width-mw)/2)|0, 10, "#e8f2ff", 1, 1);
  }

  /* =========================
     GAME STATE
     ========================= */
  function resetGame(){
    const base = getPlayerBaseSize();
    game = {
      running:true, paused:false, state:"title", t:0,
      player:{
        x:canvas.width/2,
        y:canvas.height-10,
        form: 0,
        scale: 1,
        maxHP: 3,
        hp: 3,
        bulletDamage: 1,
        shootCooldown: 7,
        _cd: 0,
        baseW: base.w,
        baseH: base.h
      },
      bullets:[],
      bosses:[],
      won:false, lost:false,
      cutscene: null,
      heartCrack: null
    };

    spawnBoss("Loraine","easy", 60, 45);
    spawnBoss("Crystal","easy", 260, 50);
    spawnBoss("Vee","hard", 90, 90);
    spawnBoss("Toni","hard", 230, 95);
    spawnBoss("Natalie","nat", 160, 55);
  }

  function spawnBoss(name, tierName, x, y){
    const tier = CONFIG.tiers[tierName];
    const size = bossSizeFor(name);
    const angle = Math.random()*Math.PI*2;
    game.bosses.push({
      name, tierName,
      hp:tier.hp, maxHp:tier.hp,
      x, y, w:size.w, h:size.h,
      vx: Math.cos(angle)*tier.speed,
      vy: Math.sin(angle)*tier.speed,
      touchCooldown:0,
      dodgeCooldown:0
    });
  }

  function transformPlayer(){
    const p = game.player;
    p.form++;
    if (p.form >= 3) p.scale = 2;
    p.maxHP += 1;
    p.hp = Math.min(p.maxHP, p.hp + 1);
    p.bulletDamage += 1;
    p.shootCooldown = Math.max(3, p.shootCooldown - 1);
  }

  function shoot(){
    if (!game || !game.running || game.paused || game.state!=="play" || game.lost) return;
    const p = game.player;
    if (p._cd > 0) return;
    p._cd = p.shootCooldown;

    const thickness = (p.form >= 3) ? 2 : 1;
    game.bullets.push({
      x:(p.x)|0,
      y:(p.y - (p.baseH*p.scale) + 2)|0,
      vy:-CONFIG.bulletSpeed,
      dmg: p.bulletDamage,
      w: thickness,
      h: 3 + (p.form >= 4 ? 1 : 0)
    });
  }

  function bossTryDodge(boss){
    if (boss.dodgeCooldown>0) return;
    const tier = CONFIG.tiers[boss.tierName];
    const bx=boss.x, by=boss.y;

    let best=9999, threat=null;
    for(const b of game.bullets){
      const dx=Math.abs(b.x-bx);
      const dy=by-b.y;
      if (dy>0 && dy<48 && dx < (boss.w/2 + 7)){
        const score = dy + dx*0.6;
        if (score<best){ best=score; threat=b; }
      }
    }
    if (!threat) return;
    if (Math.random() > tier.dodge) return;

    const dir = (Math.random()<0.5?-1:1);
    boss.vx = clamp(boss.vx + dir*(tier.speed*1.6), -2.6, 2.6);
    boss.vy = clamp(boss.vy + (Math.random()<0.5?-1:1)*(tier.speed*0.9), -2.4, 2.4);
    boss.dodgeCooldown = boss.tierName==="nat" ? 10 : boss.tierName==="hard" ? 14 : 18;
  }

  /* =========================
     CUTSCENE (UNCHANGED)
     ========================= */
  function createCutscene(){
    const center = { x: 150, y: 112 };
    const ring = [
      {name:"Loraine", kind:"easy",  x:center.x-70, y:center.y-18},
      {name:"Crystal", kind:"easy",  x:center.x-28, y:center.y-48},
      {name:"Vee",     kind:"hard",  x:center.x+28, y:center.y-48},
      {name:"Toni",    kind:"hard",  x:center.x+70, y:center.y-18},
      {name:"Natalie", kind:"nat",   x:center.x,    y:center.y-68},
    ];

    return {
      scene: 1,
      t: 0,
      phase: "setup",
      center,
      bosses: ring.map(b => ({
        ...b,
        alive:true,
        hp: (b.kind==="easy")?7 : (b.kind==="hard")?10 : 14,
        maxHp:(b.kind==="easy")?7 : (b.kind==="hard")?10 : 14,
        blink:0,
        shake:0
      })),
      male:{
        x: 340, y: 112,
        sc:2, vx:-1.1,
        attacking:false, pose:0
      },
      hero:{ x:center.x, y:center.y, sc:2, form:3 },
      slash: null,
      sparkle: [],
      holdHands:false,
      home:{
        maleX: 360, heroX: 338,
        y: 122,
        couchX: 60,
        couchY: 110,
        doorX: 284,
        moonX: 268,
        moonY: 38,
        fade: 0,
        kissPop: 0
      }
    };
  }

  function updateCutscene(){
    const c = game.cutscene;
    c.t++;

    const S = CONFIG.cutsceneSlow;
    const wait = (frames) => c.t > Math.round(frames * S);

    for (const b of c.bosses){
      if (b.blink>0) b.blink--;
      if (b.shake>0) b.shake--;
    }

    for (let i=c.sparkle.length-1;i>=0;i--){
      const s=c.sparkle[i];
      s.life--;
      s.x += s.vx; s.y += s.vy;
      s.vy += 0.02;
      if (s.life<=0) c.sparkle.splice(i,1);
    }

    if (c.slash){
      c.slash.life--;
      if (c.slash.life<=0) c.slash=null;
    }

    function puff(x,y,kind,count=6){
      for(let i=0;i<count;i++){
        c.sparkle.push({
          x, y,
          vx:(Math.random()*2-1)*(kind==="heart"?0.22:0.65),
          vy:(Math.random()*-1.2) - (kind==="heart"?0.55:0.25),
          life: (kind==="heart"?46:26) + (Math.random()*10|0),
          kind
        });
      }
    }

    if (c.scene === 1){
      if (c.phase === "setup"){
        if (wait(60)){ c.phase = "threaten"; c.t = 0; }
        return;
      }
      if (c.phase === "threaten"){
        c.male.x += c.male.vx;
        if (c.male.x <= 262){
          c.male.x = 262;
          if (c.t % Math.round(16*S) === 0) c.male.pose = (c.male.pose+1)%3;
          if (wait(95)){ c.phase = "fight"; c.t = 0; }
        }
        return;
      }
      if (c.phase === "fight"){
        const order = ["Loraine","Crystal","Vee","Toni","Natalie"];
        let target=null;
        for (const name of order){
          const b = c.bosses.find(x => x.name===name && x.alive);
          if (b){ target=b; break; }
        }
        if (!target){ c.phase = "taunt"; c.t = 0; return; }

        const tx = target.x + 10;
        const ty = target.y + 10;
        const dx = tx - c.male.x;
        const dy = ty - c.male.y;
        const dist = Math.hypot(dx,dy) || 1;
        const speed = (target.kind==="nat") ? 1.65 : (target.kind==="hard") ? 1.45 : 1.25;

        if (dist > 14){
          c.male.x += (dx/dist)*speed;
          c.male.y += (dy/dist)*speed*0.75;
          c.male.attacking=false;

          if (c.t % Math.round(10*S) === 0){
            for (const b of c.bosses){
              if (!b.alive) continue;
              b.x += (Math.random()*2-1)*0.3;
              b.y += (Math.random()*2-1)*0.3;
            }
          }
        } else {
          c.male.attacking=true;

          if (c.t % Math.round(16*S) === 0){
            c.slash = { x: target.x + 6, y: target.y + 6, life: 12 };

            const dmg = (target.kind==="nat") ? 1 : (target.kind==="hard") ? 2 : 2;
            target.hp -= dmg;
            target.blink = 10;
            target.shake = 10;

            puff(target.x+10, target.y+10, Math.random()<0.25?"heart":"star", 6);

            if (target.hp <= 0){
              target.alive=false;
              puff(target.x+10, target.y+10, "star", 10);
            }
          }
        }

        c.male.x = clamp(c.male.x, 10, 310);
        c.male.y = clamp(c.male.y, 40, 150);
        return;
      }
      if (c.phase === "taunt"){
        if (c.t % Math.round(18*S) === 0) puff(c.hero.x+10, c.hero.y-26, "heart", 3);
        if (wait(80)){ c.phase = "carry"; c.t = 0; }
        return;
      }
      if (c.phase === "carry"){
        if (c.t < Math.round(52*S)){
          const tx = c.hero.x + 26;
          const ty = c.hero.y;
          const dx = tx - c.male.x;
          const dy = ty - c.male.y;
          const dist = Math.hypot(dx,dy) || 1;
          c.male.x += (dx/dist)*1.7;
          c.male.y += (dy/dist)*1.3;
        } else {
          c.holdHands = true;
          c.male.x -= 1.85;
          c.hero.x -= 1.75;
          c.hero.y = c.center.y + ((c.t%Math.round(16*S)) < Math.round(8*S) ? 0 : 1);
          if (c.t % Math.round(10*S) === 0) puff(c.hero.x+16, c.hero.y-26, "heart", 2);
        }
        if (c.hero.x < -55){ c.phase = "blackout"; c.t = 0; }
        return;
      }
      if (c.phase === "blackout"){
        if (wait(35)){
          c.scene = 2;
          c.phase = "home_walk";
          c.t = 0;
        }
        return;
      }
    }

    if (c.scene === 2){
      if (c.phase === "home_walk"){
        c.home.heroX -= 1.9;
        c.home.maleX -= 2.0;
        if (c.t % Math.round(22*S) === 0) puff(c.home.heroX+8, c.home.y-26, "heart", 1);
        if (c.home.heroX < 250){ c.phase = "doorway"; c.t = 0; }
        return;
      }

      if (c.phase === "doorway"){
        if (c.t % Math.round(16*S) === 0) puff(c.home.doorX-10, 92, "star", 2);
        if (wait(60)){ c.phase = "couch"; c.t = 0; }
        return;
      }

      if (c.phase === "couch"){
        const targetHeroX = c.home.couchX + 102;
        const targetMaleX = targetHeroX + 22;

        c.home.heroX += clamp(targetHeroX - c.home.heroX, -1.7, 1.7);
        c.home.maleX += clamp(targetMaleX - c.home.maleX, -1.8, 1.8);

        if (c.t % Math.round(20*S) === 0) puff(c.home.couchX+128, c.home.couchY-22, "heart", 1);

        const closeEnough = Math.abs(c.home.heroX - targetHeroX) < 1.2 && Math.abs(c.home.maleX - targetMaleX) < 1.2;
        if (closeEnough && wait(70)){
          c.phase = "kiss";
          c.t = 0;
          c.home.kissPop = 0;
        }
        return;
      }

      if (c.phase === "kiss"){
        if (c.t % Math.round(14*S) === 0){
          puff(c.home.couchX+128, c.home.couchY-30, "heart", 3);
          c.home.kissPop = 10;
        }
        if (c.home.kissPop > 0) c.home.kissPop--;
        if (wait(140)){ c.phase = "stargaze"; c.t = 0; }
        return;
      }

      if (c.phase === "stargaze"){
        if (c.t % Math.round(26*S) === 0) puff(c.home.moonX-18, c.home.moonY+10, "heart", 1);
        if (wait(140)){ c.phase = "fade"; c.t = 0; }
        return;
      }

      if (c.phase === "fade"){
        c.home.fade = clamp(c.home.fade + (0.02 / CONFIG.cutsceneSlow), 0, 1);
        if (c.home.fade >= 1){
          game.cutscene = null;
          game.state = "heart";
          showToast("DATE NIGHT UNLOCKED ❤️");
        }
        return;
      }
    }
  }

  function drawCutscene(){
    const c = game.cutscene;

    ctx.fillStyle="#02020a";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    drawStars(game.t);

    ctx.fillStyle="rgba(0,0,0,.60)";
    ctx.fillRect(4,4,312,22);
    ctx.strokeStyle="rgba(255,255,255,.12)";
    ctx.strokeRect(4,4,312,22);
    drawPixelText("LEVEL 2", 10, 10, "#7cff9f", 1, 1);

    for (const s of c.sparkle){
      if (s.kind==="heart"){
        ctx.fillStyle="rgba(255,107,214,.92)";
        ctx.fillRect(s.x|0, s.y|0, 3, 2);
        ctx.fillRect((s.x+1)|0, (s.y-1)|0, 1, 4);
      } else {
        ctx.fillStyle="rgba(255,214,107,.92)";
        ctx.fillRect(s.x|0, s.y|0, 2, 2);
      }
    }

    if (c.scene===1 && c.phase==="blackout"){
      ctx.fillStyle="rgba(0,0,0,.85)";
      ctx.fillRect(0,0,320,180);
      drawPixelText("SAVING PROGRESS...[DAEV <3 YUZU]", 96, 86, "#e8f2ff", 1, 1);
      return;
    }

    if (c.scene === 1){
      ctx.fillStyle="rgba(255,255,255,.06)";
      ctx.fillRect(0,140,320,40);

      drawPlayerVampireCat((c.hero.x-12)|0, (c.hero.y-22)|0, c.hero.sc, c.hero.form);

      for (const b of c.bosses){
        if (!b.alive) continue;
        const blink = b.blink>0 && ((b.blink%2)===0);
        const shakeX = b.shake>0 ? ((b.shake%2)?1:-1) : 0;
        const shakeY = b.shake>0 ? ((b.shake%3)?0:1) : 0;
        const bx = (b.x + shakeX)|0;
        const by = (b.y + shakeY)|0;

        if (b.name==="Natalie") drawNatalieGothCat(bx, by, b.hp, b.maxHp, blink);
        else if (b.name==="Vee" || b.name==="Toni") drawGangsterCat(bx, by, b.name, b.hp, b.maxHp, blink);
        else drawBossClassic(bx, by, b.name, b.hp, b.maxHp, blink);
      }

      drawMaleCat((c.male.x-12)|0, (c.male.y-22)|0, c.male.sc, c.t);

      if (c.slash){
        const s=c.slash;
        ctx.fillStyle="rgba(255,214,107,.92)";
        ctx.fillRect((s.x)|0,(s.y)|0,14,2);
        ctx.fillRect((s.x+4)|0,(s.y-2)|0,10,2);
        ctx.fillRect((s.x+6)|0,(s.y+2)|0,8,2);
        drawPixelText("POW!", (s.x+2)|0, (s.y-10)|0, "#ffd66b", 1, 1);
      }

      if (c.phase==="setup"){
        drawDialogue(["NAT: GURLIEESSS PROTECT HER", "DAEV ENTERS THE ALLEY..."], "#e8f2ff","#ffd66b");
      } else if (c.phase==="threaten"){
        drawDialogue(["DAEV: YOU'RE COMING WITH ME.", ""], "#ffd66b","#ffd66b");
      } else if (c.phase==="fight"){
        drawDialogue(["DAEV: STAY AWAY FROM MY YUZU!!!", ""], "#ffd66b","#ffd66b");
      } else if (c.phase==="taunt"){
        drawDialogue(["VICTORY... YUZU is all Daev's Now.", ""], "#7aa7ff","#7aa7ff");
      } else if (c.phase==="carry"){
        drawDialogue(["EXTRACTION: SUCCESS", c.holdHands ? "<3" : ""], "#7cff9f","#ff6bd6");
      } else {
        drawDialogue(["", ""], "#e8f2ff","#e8f2ff");
      }
      return;
    }

    if (c.scene === 2){
      ctx.fillStyle="rgba(122,167,255,.06)";
      ctx.fillRect(0,26,320,114);
      ctx.fillStyle="rgba(255,255,255,.06)";
      ctx.fillRect(0,140,320,40);

      ctx.fillStyle="rgba(255,214,107,.12)";
      ctx.fillRect(238, 30, 70, 44);
      ctx.fillStyle="rgba(255,214,107,.92)";
      ctx.fillRect(c.home.moonX, c.home.moonY, 10, 10);

      ctx.fillStyle="rgba(255,214,107,.14)";
      ctx.fillRect(c.home.doorX, 62, 26, 60);
      ctx.fillStyle="rgba(255,214,107,.35)";
      ctx.fillRect(c.home.doorX+18, 92, 3, 3);

      const cx=c.home.couchX, cy=c.home.couchY;
      ctx.fillStyle="rgba(255,107,214,.16)";
      ctx.fillRect(cx, cy, 170, 24);
      ctx.fillRect(cx+10, cy-18, 150, 18);
      ctx.strokeStyle="rgba(255,255,255,.10)";
      ctx.strokeRect(cx+0.5, cy+0.5, 170-1, 24-1);
      ctx.strokeRect(cx+10.5, cy-18+0.5, 150-1, 18-1);

      if (c.phase==="home_walk" || c.phase==="doorway"){
        drawPlayerVampireCat((c.home.heroX-12)|0, (c.home.y-22)|0, 2, 3);
        drawMaleCat((c.home.maleX-12)|0, (c.home.y-22)|0, 2, c.t);
      } else {
        const sitY = cy + 2;
        drawPlayerVampireCat((cx+102)|0, (sitY-22)|0, 2, 3);
        drawMaleCat((cx+126)|0, (sitY-22)|0, 2, c.t);
        ctx.fillStyle="rgba(124,255,159,.10)";
        ctx.fillRect(cx+96, cy+10, 78, 12);
      }

      if (c.phase==="home_walk"){
        drawDialogue(["GOING HOME", "CO-OP MODE: ON"], "#7cff9f", "#ffd66b");
      } else if (c.phase==="doorway"){
        drawDialogue(["GOING HOME", "DOOR UNLOCKED. SAFE ZONE."], "#7cff9f", "#e8f2ff");
      } else if (c.phase==="couch"){
        drawDialogue(["COZY MODE", ""], "#7cff9f", "#e8f2ff");
      } else if (c.phase==="kiss"){
        drawDialogue(["KISS MODE: ENABLED", "CONSENSUAL + SWEET + SOFT"], "#7cff9f", "#e8f2ff");
        if (c.home.kissPop>0) drawPixelText("KISS!", 148, 78, "#ff6bd6", 1, 1);
      } else if (c.phase==="stargaze"){
        drawDialogue(["QUIET TIME.", "MOONLIGHT + HEARTS"], "#7cff9f", "#ffd66b");
      } else if (c.phase==="fade"){
        drawDialogue(["FADE TO BLACK...", ""], "#ffd66b", "#e8f2ff");
      } else {
        drawDialogue(["", ""], "#e8f2ff", "#e8f2ff");
      }

      if (c.phase==="fade"){
        ctx.fillStyle = `rgba(0,0,0,${c.home.fade})`;
        ctx.fillRect(0,0,320,180);
      }
      return;
    }
  }

  /* =========================
     UPDATE/DRAW
     ========================= */
  function update(){
    if (!game || game.paused) return;

    if (game.state === "play") updatePlay();
    else if (game.state === "cutscene") updateCutscene();
    else if (game.state === "heart_crack") updateHeartCrack();
  }

  function updatePlay(){
    if (!game.running) return;

    const p = game.player;
    if (p._cd > 0) p._cd--;

    let dx=0;
    if (keys["a"]||keys["arrowleft"]) dx-=1;
    if (keys["d"]||keys["arrowright"]) dx+=1;

    if (tilt.enabled){
      const tx = Math.abs(tilt.x) < tilt.dead ? 0 : tilt.x;
      dx += tx * 2.2;
    }

    const halfW = (p.baseW * p.scale)/2;
    p.x = clamp(p.x + dx*CONFIG.playerSpeed, 6 + halfW, canvas.width - (6 + halfW));

    for(let i=game.bullets.length-1;i>=0;i--){
      const b=game.bullets[i];
      b.y += b.vy;
      if (b.y < -16) game.bullets.splice(i,1);
    }

    for(const boss of game.bosses){
      const tier = CONFIG.tiers[boss.tierName];
      if (boss.touchCooldown>0) boss.touchCooldown--;
      if (boss.dodgeCooldown>0) boss.dodgeCooldown--;

      bossTryDodge(boss);

      boss.vx += (Math.random()*2-1)*tier.jitter;
      boss.vy += (Math.random()*2-1)*tier.jitter;

      boss.vx = clamp(boss.vx, -2.6, 2.6);
      boss.vy = clamp(boss.vy, -2.4, 2.4);

      boss.x += boss.vx;
      boss.y += boss.vy;

      const marginX = boss.w/2 + 2;
      const marginYTop = boss.h/2 + 26;
      const marginYBot = boss.h/2 + 10;

      if (boss.x < marginX){ boss.x=marginX; boss.vx*=-1; }
      if (boss.x > canvas.width-marginX){ boss.x=canvas.width-marginX; boss.vx*=-1; }
      if (boss.y < marginYTop){ boss.y=marginYTop; boss.vy*=-1; }
      if (boss.y > canvas.height-marginYBot){ boss.y=canvas.height-marginYBot; boss.vy*=-1; }

      const bossRect={ x:boss.x-boss.w/2, y:boss.y-boss.h/2, w:boss.w, h:boss.h };
      const plyRect={
        x:p.x-(p.baseW*p.scale)/2,
        y:p.y-(p.baseH*p.scale),
        w:p.baseW*p.scale,
        h:p.baseH*p.scale
      };
      if (rectHit(bossRect.x,bossRect.y,bossRect.w,bossRect.h, plyRect.x,plyRect.y,plyRect.w,plyRect.h) && boss.touchCooldown===0){
        boss.touchCooldown=26;
        const dmgTaken = (p.form >= 4) ? 0.5 : (p.form >= 3) ? 0.75 : 1;
        p.hp -= dmgTaken;
        if (p.hp <= 0){
          game.lost=true; game.running=false;
          showToast("YOU DIED — PRESS R");
          return;
        }
      }
    }

    for(let bi=game.bullets.length-1; bi>=0; bi--){
      const b=game.bullets[bi];
      let hitBossIndex = -1;

      for(let i=game.bosses.length-1; i>=0; i--){
        const boss=game.bosses[i];
        const r={ x:boss.x-boss.w/2, y:boss.y-boss.h/2, w:boss.w, h:boss.h };
        if (rectHit(b.x,b.y,b.w,b.h, r.x,r.y,r.w,r.h)){
          hitBossIndex = i;
          boss.hp -= b.dmg;
          break;
        }
      }

      if (hitBossIndex !== -1){
        game.bullets.splice(bi,1);
        const boss = game.bosses[hitBossIndex];
        if (boss.hp <= 0){
          game.bosses.splice(hitBossIndex,1);
          transformPlayer();
        }
      }
    }

    if (game.bosses.length===0){
      game.running=false;
      game.state="cutscene";
      game.cutscene = createCutscene();
      showToast("YOU DEFEATED THE GURLIEESSS!");
    }
  }

  function draw(){
    if (!game) return;

    const heartCursor = (game.state === "heart" && heartHitRect) ? true : false;
    canvas.style.cursor = heartCursor ? "pointer" : (game.state==="title" ? "pointer" : "default");

    if (game.state === "title") drawTitleScreen();
    else if (game.state === "play") drawPlay();
    else if (game.state === "cutscene") drawCutscene();
    else if (game.state === "heart") drawHeartScreen();
    else if (game.state === "heart_crack") drawHeartCrackScreen();
    else if (game.state === "itinerary") drawItineraryScreen();
  }

  function drawPlay(){
    ctx.fillStyle="#02020a";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    drawStars(game.t);

    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(4,4,312,22);
    ctx.strokeStyle="rgba(255,255,255,.12)";
    ctx.strokeRect(4,4,312,22);

    const p = game.player;
    drawPixelText(`HP:${(p.hp%1? p.hp.toFixed(1): p.hp)}/${p.maxHP}`, 8, 8, "#ff6bd6", 1, 1);
    drawPixelText(`FORM:${p.form}`, 98, 8, "#7aa7ff", 1, 1);
    drawPixelText(`DMG:${p.bulletDamage}`, 168, 8, "#ffd66b", 1, 1);
    drawPixelText(`GURLIEESSS:${game.bosses.length}`, 244, 8, "#e8f2ff", 1, 1);

    const pw = p.baseW * p.scale;
    const ph = p.baseH * p.scale;
    drawPlayerVampireCat(((p.x - pw/2)|0), ((p.y - ph)|0), p.scale, p.form);

    ctx.fillStyle="#e8f2ff";
    for(const b of game.bullets) ctx.fillRect(b.x|0, b.y|0, b.w, b.h);

    for(const boss of game.bosses){
      const n=boss.name.toLowerCase();
      const x=(boss.x-boss.w/2)|0;
      const y=(boss.y-boss.h/2)|0;

      if (n==="natalie") drawNatalieGothCat(x,y, boss.hp, boss.maxHp);
      else if (n==="vee" || n==="toni") drawGangsterCat(x,y, boss.name, boss.hp, boss.maxHp);
      else drawBossClassic(x,y, boss.name, boss.hp, boss.maxHp);
    }
  }

  /* =========================
     MAIN LOOP
     ========================= */
  function loop(){
    requestAnimationFrame(loop);
    if (game) update();
    if (game) game.t++;
    draw();
  }

  /* =========================
     INPUT (keyboard)
     ========================= */
  window.addEventListener("keydown", (e)=>{
    const k=e.key.toLowerCase();
    keys[k]=true;

    if (k===" "){
      e.preventDefault();
      if (game && game.state==="title") startGameFromTitle();
      else shoot();
    }

    if (k==="p" && game && game.state==="play"){
      game.paused=!game.paused;
      showToast(game.paused?"PAUSED":"RESUMED");
    }

    if (k==="r"){
      resetGame();
      fitCanvasLandscapeMobile();
      showToast("RESET!");
    }
  });

  window.addEventListener("keyup", (e)=>{ keys[e.key.toLowerCase()] = false; });

  // ✅ start
  resetGame();
  fitCanvasLandscapeMobile();
  loop();
})();
</script>
</body>
</html>